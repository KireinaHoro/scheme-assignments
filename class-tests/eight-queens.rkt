#lang racket
(define (enumerate-interval start end)
  (define (iter curr result)
    (if (< curr start)
        result
        (iter (- curr 1)
              (cons curr result))))
  (iter end null))
(define (flatmap proc seq)
  (foldr append null (map proc seq)))
(define (queens board-size)
  (define empty-board null)
  (define (safe? k pos)
    (define (check-cross?)
      (andmap (lambda (i)
                (not (eq? (abs (- (list-ref pos i)
                                  (car pos)))
                          i)))
              (enumerate-interval 1 (- k 1))))
    (and (null? (filter (lambda (x) (eq? x (car pos)))
                        (cdr pos)))
         (check-cross?)))
  (define (adjoin-position new-row k rest-of-queens)
    (cons new-row rest-of-queens))
  (define (queen-cols k)
    (if (eq? k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
(define (proc-result l)
  (foldr (lambda (x acc) (+ x (* acc 10)))
         0 l))
(define ret (queens 8))
(define (main)
  (define n (read))
  (let ll ((input (read))
           (remaining n))
    (begin (displayln (proc-result
                       (list-ref ret (- input 1))))
           (if (> remaining 1)
               (ll (read) (- remaining 1))
               (void)))))
(main)